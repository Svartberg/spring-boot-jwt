# Spring Boot service with JWT Auth

## Задание

В БД создать пару sql табличек со связями (foreign keys)

Сделать HTTP POST эндпоинт, который получает данные в json вида:
```json
{
  "name": "имя отправителя",
  "password": "пароль"
}
```
этот эндпоинт проверяет пароль по БД и создает jwt токен (срок действия токена и алгоритм подписи не принципиален, для генерации и работе с токеном можно использовать готовую библиотечку) в токен записывает данные: name: "имя отправителя"
и отправляет токен в ответ, тоже json вида:
```json
{
  "token": "тут сгенерированный токен"
}
```
Сервер слушает и отвечает в какой-нибудь эндпоинт, в него на вход поступают данные в формате json:
Сообщения клиента-пользователя:
```json
{
  "name": "имя отправителя",
  "message": "текст сообщение"
}
```
В заголовках указан Bearer токен, полученный из эндпоинта выше (между Bearer и полученным токеном должно быть нижнее подчеркивание).
Проверить токен, в случае успешной проверки токена, полученное сообщение сохранить в БД.

Если пришло сообщение вида:
```json
{
  "name": "имя отправителя",
  "message": "history 10"
}
```
проверить токен, в случае успешной проверки токена отправить отправителю 10 последних сообщений из БД

Добавить описание и инструкцию по запуску и комментарии в коде, если изменяете формат сообщений, то подробное описание ендпоинтов и их полей.

Завернуть все компоненты в докер, покрыть код тестами.

Проект необходимо выкладывать на github и docker hub. Обязательно наличие readme-файла.
При отсутствии полноценного readme-файла проверка тестового задания производиться не будет!

Порт 8080 НЕ УКАЗЫВАТЬ!!!

Составить запросы (curl) через терминал для проверки работоспособности вашей программы (приложить файл с запросами).

## Запуск и тестирование приложения

1. Запустить проект

```
$ mvn spring-boot:run
```

2. Перейти `http://localhost:8090/swagger-ui.html` для ознакомления с API проекта

```yml
server:
  port: 8090
```

3. Для получения токена сделать POST запрос `/users/signin`. Для тестирования был предварительно сконфигурирован пользователь со следующими данными:
```
name: client
password: client
```
Пример запроса
```
$ curl --location --request POST 'http://localhost:8090/users/signin' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "client",
    "password": "client"
}'
```
4. В случае необходимости можно создать нового пользователя. Пример запроса:
```
$ curl --location --request POST 'http://localhost:8090/users/signup' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name":"test",
    "password":"test"
    }'
```
В результате запроса из пункта 4 и пункта 3 привет ответ (в положительном случае) вида:
```json
{
    "token": "eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidGVzdCIsImlhdCI6MTY1OTY4MTM2MCwiZXhwIjoxNjU5NjgxNjYwfQ.J5-ZGeGGAV94-JSClT8csmyYRThKbbrFTVrgz7rbr5w"
}
```

6. Для сохранения сообщения необходимо в запросе добавить header авторизации в котором будет полученный JWT token.
```
'Authorization: Bearer_<jwt_token>' 
```
Пример запроса для сохранения сообщения
```
$ curl --location --request POST 'http://localhost:8090/messages/' \
--header 'Authorization: Bearer_<jwt_token>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name":"test",
    "message":"my very nice message"
    }'
```
Пример запроса для получения 10 последних сообщений
```
$ curl --location --request POST 'http://localhost:8090/messages/' \
--header 'Authorization: Bearer_<jwt_token>' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name":"test",
    "message":"history 10"
    }'
```

## JSON Web Token

это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности.

Пример JWT
```json
{
  "name": "client",
  "iat": 1659678745,
  "exp": 1659679045
}
```

iat - созданная временная метка;

exp - временная метка истечения срока действия;

# Детали реализации

Данное приложение использует для аутентификации совмещает **JWT** и **Spring Security**. Spring Security framework поставляется с подключаемыми классами, в которых уже есть механизмы авторизации: **cookie**, **HTTP Basic** и **HTTP Digest**. Тем не менее, в нем отсутствует встроенная поддержка **JWT**. Для работы с **JWT** используется библиотека **JSON Web Token Support**.

## H2 DB

На данный момент, приложение использует базу данных H2 с именем **test_db**.

```yml
spring:
  datasource:
    url: jdbc:h2:mem:test_db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: root
    password: root
  tomcat:
    max-wait: 20000
    max-active: 50
    max-idle: 20
    min-idle: 15
  jpa:
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
        id:
          new_generator_mappings: false
```
## Security

### JwtTokenFilter

`JwtTokenFilter` фильтр применяется к каждому API (/**), за исключением эндпоинта токена подписи (/users/signin) и  эндпоинта singup (/users/signup).

Этот фильтр выполняет следующие функции:
 1. Проверяет наличие токена доступа в заголовке авторизации. Если маркер доступа найден в заголовке, делегирует проверку подлинности `JwtTokenProvider`, в противном случае выдаёт исключение проверки подлинности;
 2. Вызывает стратегии **success** или **failure**, основанные на результатах процесса аутентификации, выполняемого `JwtTokenProvider`.

### JwtTokenFilterConfigurer

Добавляет `JwtTokenFilter` в `Defaultsecurityfilter` у spring boot security.

### JwtTokenProvider

1. Проверяет подпись токена доступа;
2. Извлекает подтверждения об идентификации и авторизации из токена доступа и использует их для создания **UserContext**;
3. Если маркер доступа неверно сформирован, истек срок действия или просто если маркер не подписан соответствующим ключом подписи, будет выдано исключение аутентификации.

### MyUserDetails

Имплементирует `UserDetailsService` для определения пользовательской функции `loadUserByUsername`.
Интерфейс `UserDetailsService` используется для извлечения данных, связанных с пользователем. У него есть один метод с именем `loadUserByUsername`, который находит объект пользователя на основе имени пользователя и может быть переопределен для настройки процесса поиска пользователя.

Он используется `DaoAuthenticationProvider` для загрузки сведений о пользователе во время аутентификации.

### WebSecurityConfig

Класс `WebSecurityConfig` расширяет `WebSecurityConfigurerAdapter` для обеспечения пользовательской конфигурации безопасности.

В этом классе настраиваются и создаются следующие компоненты:
1. JwtTokenFilter
2. PasswordEncoder

Кроме того, внутри метода `WebSecurityConfig#configure(HttpSecurity http)` настраивается шаблон для определения защищенных и/или незащищенных API эндпойнтов. Защита **CSRF**, поскольку файлы cookie не используются.